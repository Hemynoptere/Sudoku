<!DOCTYPE html>

<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur de Sudoku</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: white;
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0;
        margin: 0;
    }

    .container {
        background: white;
        border-radius: 0;
        padding: 10px;
        box-shadow: none;
        max-width: 700px;
    }

    h1 {
        text-align: center;
        color: #667eea;
        margin: 5px 0 3px 0;
        font-size: 1.1em;
    }

    .controls {
        display: flex;
        gap: 4px;
        margin-bottom: 2px;
        flex-wrap: wrap;
        justify-content: center;
    }

    button {
        padding: 3px 6px;
        border: none;
        border-radius: 4px;
        font-size: 9px;
        cursor: pointer;
        transition: all 0.3s;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.2px;
    }

    .difficulty-btn {
        background: #667eea;
        color: white;
        padding: 5px 10px;
        font-size: 9px;
    }

    .difficulty-btn:hover {
        background: #5568d3;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    .difficulty-btn.active {
        background: #764ba2;
    }

    .empty-btn {
        background: #38a169;
    }

    .empty-btn:hover {
        background: #2f855a;
    }

    .action-btn {
        background: #48bb78;
        color: white;
    }

    .action-btn:hover {
        background: #38a169;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(72, 187, 120, 0.4);
    }

    .solve-btn {
        background: #ed8936;
    }

    .solve-btn:hover {
        background: #dd6b20;
        box-shadow: 0 5px 15px rgba(237, 137, 54, 0.4);
    }

    .verify-btn {
        background: #3182ce;
    }

    .verify-btn:hover {
        background: #2c5282;
        box-shadow: 0 5px 15px rgba(49, 130, 206, 0.4);
    }

    button:disabled {
        background: #cbd5e0;
        color: #a0aec0;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
    }

    button:disabled:hover {
        background: #cbd5e0;
        transform: none;
        box-shadow: none;
    }

    .checkbox-label {
        display: flex;
        align-items: center;
        gap: 3px;
        font-size: 9px;
        color: #2d3748;
        cursor: pointer;
        padding: 3px 6px;
        background: #edf2f7;
        border-radius: 4px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.2px;
    }

    .checkbox-label input[type="checkbox"] {
        cursor: pointer;
        width: 12px;
        height: 12px;
    }

    .checkbox-label:hover {
        background: #e2e8f0;
    }

    .pair-control {
        margin-top: 2px;
        display: flex;
        justify-content: center;
        gap: 4px;
    }

    .sudoku-container {
        position: relative;
        margin: 0 auto;
        width: fit-content;
    }

    .sudoku-grid {
        display: grid;
        grid-template-columns: repeat(9, 1fr);
        gap: 0;
        border: none;
        border-radius: 8px;
        overflow: visible;
        width: fit-content;
        box-shadow: none;
        padding: 40px 40px 40px 50px;
        background: white;
        position: relative;
    }

    .cell {
        width: 65px;
        height: 65px;
        border: 1px solid #cbd5e0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 26px;
        font-weight: 600;
        background: white;
        transition: all 0.2s;
        position: relative;
    }

    .cell input {
        width: 100%;
        height: 100%;
        border: none;
        text-align: center;
        font-size: 26px;
        font-weight: 600;
        background: transparent;
        position: relative;
        z-index: 2;
    }

    .pair-hint-right {
        position: absolute;
        right: -8px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 13px;
        color: #ed8936;
        font-weight: 700;
        background: white;
        padding: 1px 2px;
        z-index: 10;
        white-space: nowrap;
        display: none;
    }

    .pair-hint-bottom {
        position: absolute;
        bottom: -8px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 13px;
        color: #ed8936;
        font-weight: 700;
        background: white;
        padding: 1px 2px;
        z-index: 10;
        white-space: nowrap;
        display: none;
    }

    .pair-hint-right.show,
    .pair-hint-bottom.show {
        display: block;
    }

    .simple-hint {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 13px;
        color: #48bb78;
        font-weight: 700;
        z-index: 5;
        display: none;
    }

    .simple-hint.show {
        display: block;
    }

    .pointing-pair-right {
        position: absolute;
        right: -8px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 13px;
        color: #ed8936;
        font-weight: 700;
        background: white;
        padding: 1px 2px;
        z-index: 10;
        white-space: nowrap;
        display: none;
    }

    .pointing-pair-bottom {
        position: absolute;
        bottom: -8px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 13px;
        color: #ed8936;
        font-weight: 700;
        background: white;
        padding: 1px 2px;
        z-index: 10;
        white-space: nowrap;
        display: none;
    }

    .pointing-pair-right.show,
    .pointing-pair-bottom.show {
        display: block;
    }

    .triple-hint-left {
        position: absolute;
        left: -8px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 13px;
        color: #3182ce;
        font-weight: 700;
        background: white;
        padding: 1px 2px;
        z-index: 10;
        white-space: nowrap;
        display: none;
    }

    .triple-hint-top {
        position: absolute;
        top: -8px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 13px;
        color: #3182ce;
        font-weight: 700;
        background: white;
        padding: 1px 2px;
        z-index: 10;
        white-space: nowrap;
        display: none;
    }

    .triple-hint-left.show,
    .triple-hint-top.show {
        display: block;
    }

    .row-hints {
        position: absolute;
        left: 6px;
        top: 40px;
        width: 40px;
        height: 585px;
        pointer-events: none;
    }

    .row-hint {
        position: absolute;
        left: 0;
        width: 40px;
        height: 65px;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 10px;
        color: #718096;
        font-weight: 600;
        line-height: 1.4;
    }

    .row-hint-line {
        white-space: nowrap;
    }

    .row-hint.show {
        display: flex;
    }

    .column-hints {
        position: absolute;
        top: 6px;
        left: 50px;
        width: 585px;
        height: 30px;
        pointer-events: none;
    }

    .column-hint {
        position: absolute;
        top: 0;
        width: 65px;
        height: 30px;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 10px;
        color: #718096;
        font-weight: 600;
        line-height: 1.4;
    }

    .column-hint-line {
        white-space: nowrap;
    }

    .ariane-hint {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 58px;
        height: 58px;
        border: 3px solid #9333ea;
        border-radius: 50%;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: rgba(147, 51, 234, 0.05);
        z-index: 5;
        pointer-events: none;
    }

    .ariane-candidates {
        font-size: 9px;
        color: #9333ea;
        font-weight: 600;
        line-height: 1.2;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        max-width: 50px;
        gap: 2px;
    }

    .ariane-best {
        font-weight: 900;
        font-size: 11px;
    }

    .ariane-hint.show {
        display: flex;
    }

    .xwing-overlay {
        position: absolute;
        pointer-events: none;
        z-index: 15;
        display: none;
    }

    .xwing-rect {
        position: absolute;
        border: 3px solid #dc2626;
        background: rgba(220, 38, 38, 0.05);
        pointer-events: none;
    }

    .xwing-label {
        position: absolute;
        background: #dc2626;
        color: white;
        padding: 2px 4px;
        font-size: 9px;
        font-weight: 700;
        border-radius: 3px;
        white-space: nowrap;
    }

    .xwing-overlay.show {
        display: block;
    }

    .column-hint.show {
        display: flex;
    }

    .hint-number {
        margin: 0;
    }

    .cell input:focus {
        outline: none;
        background: #edf2f7;
    }

    .cell.given {
        background: #e6fffa;
        color: #2d3748;
    }

    .cell.given input {
        color: #2d3748;
        cursor: not-allowed;
    }

    .cell.solved {
        background: #c6f6d5;
        color: #22543d;
    }

    .cell.error {
        background: #fed7d7;
        color: #c53030;
    }

    .cell.error input {
        color: #c53030;
    }

    .cell:nth-child(3n):not(:nth-child(9n)) {
        border-right: 3px solid #2d3748;
    }

    .cell:nth-child(n+19):nth-child(-n+27),
    .cell:nth-child(n+46):nth-child(-n+54) {
        border-bottom: 3px solid #2d3748;
    }

    .difficulty-info {
        text-align: center;
        margin-bottom: 2px;
        padding: 2px;
        background: #edf2f7;
        border-radius: 4px;
        color: #2d3748;
        font-size: 9px;
    }

    @media (max-width: 600px) {
        .cell {
            width: 35px;
            height: 35px;
            font-size: 16px;
        }

        .cell input {
            font-size: 16px;
        }

        h1 {
            font-size: 1.8em;
        }

        .container {
            padding: 20px;
        }
    }
</style>
```

</head>
<body>
    <div class="container">

```
    <div class="controls">
        <button class="difficulty-btn" data-difficulty="facile">Facile</button>
        <button class="difficulty-btn" data-difficulty="moyen">Moyen</button>
        <button class="difficulty-btn" data-difficulty="difficile">Difficile</button>
        <button class="difficulty-btn" data-difficulty="expert">Expert</button>
        <button class="difficulty-btn empty-btn" onclick="generateEmptyGrid()">Vierge</button>
    </div>

    <div class="controls">
        <button class="action-btn" onclick="generateNewSudoku()">Cr√©er</button>
        <button class="action-btn verify-btn" id="verifyBtn" onclick="verifySudoku()" disabled>V√©rifier</button>
        <button class="action-btn solve-btn" id="solveBtn" onclick="solveSudoku()" disabled>R√©soudre</button>
        <button class="action-btn" onclick="resetGrid()">Vider</button>
    </div>

    <div class="sudoku-container">
        <div class="sudoku-grid" id="sudokuGrid"></div>
        <div class="xwing-overlay" id="xwingOverlay"></div>
    </div>

    <div class="pair-control">
        <label class="checkbox-label">
            <input type="checkbox" id="showSimples" onchange="toggleSimples()">
            <span>Simples</span>
        </label>
        <label class="checkbox-label">
            <input type="checkbox" id="showPointingPairs" onchange="togglePointingPairs()">
            <span>Paires</span>
        </label>
        <label class="checkbox-label">
            <input type="checkbox" id="showCandidates" onchange="toggleCandidates()">
            <span>Doubles</span>
        </label>
        <label class="checkbox-label">
            <input type="checkbox" id="showTriples" onchange="toggleTriples()">
            <span>Triples</span>
        </label>
        <label class="checkbox-label">
            <input type="checkbox" id="showRows" onchange="toggleRows()">
            <span>Lignes</span>
        </label>
        <label class="checkbox-label">
            <input type="checkbox" id="showColumns" onchange="toggleColumns()">
            <span>Colonnes</span>
        </label>
        <label class="checkbox-label">
            <input type="checkbox" id="showAriane" onchange="toggleAriane()">
            <span>Fil</span>
        </label>
        <label class="checkbox-label">
            <input type="checkbox" id="showXWing" onchange="toggleXWing()">
            <span>X-Wing</span>
        </label>
    </div>
</div>

<script>
    let currentDifficulty = 'moyen';
    let currentPuzzle = [];
    let solution = [];
    let givenCells = [];
    let isEmptyGridMode = false;

    const difficultyLevels = {
        facile: { clues: 45, description: '45 cases remplies' },
        moyen: { clues: 35, description: '35 cases remplies' },
        difficile: { clues: 27, description: '27 cases remplies' },
        expert: { clues: 22, description: '22 cases remplies' }
    };

    // Initialisation
    document.addEventListener('DOMContentLoaded', () => {
        createGrid();
        setupDifficultyButtons();
        generateNewSudoku();
    });

    function createGrid() {
        const grid = document.getElementById('sudokuGrid');
        const container = grid.parentElement;
        
        grid.innerHTML = '';
        
        // Supprimer les anciens conteneurs d'indices s'ils existent
        const oldRowHints = document.getElementById('rowHints');
        const oldColumnHints = document.getElementById('columnHints');
        if (oldRowHints) oldRowHints.remove();
        if (oldColumnHints) oldColumnHints.remove();
        
        // Cr√©er les conteneurs pour les indices de lignes et colonnes
        const rowHintsContainer = document.createElement('div');
        rowHintsContainer.className = 'row-hints';
        rowHintsContainer.id = 'rowHints';
        
        const columnHintsContainer = document.createElement('div');
        columnHintsContainer.className = 'column-hints';
        columnHintsContainer.id = 'columnHints';
        
        // Cr√©er les divs pour chaque ligne (9 lignes)
        for (let row = 0; row < 9; row++) {
            const rowHint = document.createElement('div');
            rowHint.className = 'row-hint';
            rowHint.style.top = (row * 65) + 'px';
            rowHint.id = `row-hint-${row}`;
            rowHintsContainer.appendChild(rowHint);
        }
        
        // Cr√©er les divs pour chaque colonne (9 colonnes)
        for (let col = 0; col < 9; col++) {
            const columnHint = document.createElement('div');
            columnHint.className = 'column-hint';
            columnHint.style.left = (col * 65) + 'px';
            columnHint.id = `column-hint-${col}`;
            columnHintsContainer.appendChild(columnHint);
        }
        
        // Ajouter les conteneurs au container (pas √† la grille)
        container.appendChild(rowHintsContainer);
        container.appendChild(columnHintsContainer);
        
        for (let i = 0; i < 81; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.maxLength = 1;
            input.dataset.index = i;
            
            input.addEventListener('input', (e) => {
                const value = e.target.value;
                if (value && (!/^[1-9]$/.test(value))) {
                    e.target.value = '';
                }
                checkGridCompletion();
                updateAllHints();
            });
            
            // Cr√©er les divs pour afficher les diff√©rents types d'indices
            const pairHintRight = document.createElement('div');
            pairHintRight.className = 'pair-hint-right';
            
            const pairHintBottom = document.createElement('div');
            pairHintBottom.className = 'pair-hint-bottom';
            
            const simpleHint = document.createElement('div');
            simpleHint.className = 'simple-hint';
            
            const pointingPairRight = document.createElement('div');
            pointingPairRight.className = 'pointing-pair-right';
            
            const pointingPairBottom = document.createElement('div');
            pointingPairBottom.className = 'pointing-pair-bottom';
            
            const tripleHintLeft = document.createElement('div');
            tripleHintLeft.className = 'triple-hint-left';
            
            const tripleHintTop = document.createElement('div');
            tripleHintTop.className = 'triple-hint-top';
            
            const arianeHint = document.createElement('div');
            arianeHint.className = 'ariane-hint';
            
            cell.appendChild(pairHintRight);
            cell.appendChild(pairHintBottom);
            cell.appendChild(simpleHint);
            cell.appendChild(pointingPairRight);
            cell.appendChild(pointingPairBottom);
            cell.appendChild(tripleHintLeft);
            cell.appendChild(tripleHintTop);
            cell.appendChild(arianeHint);
            cell.appendChild(input);
            grid.appendChild(cell);
        }
    }

    function setupDifficultyButtons() {
        const buttons = document.querySelectorAll('.difficulty-btn[data-difficulty]');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentDifficulty = btn.dataset.difficulty;
                updateDifficultyInfo();
                generateNewSudoku();
            });
        });
        
        // Activer le niveau moyen par d√©faut
        buttons[1].classList.add('active');
        updateDifficultyInfo();
    }

    function generateEmptyGrid() {
        // D√©sactiver tous les boutons de difficult√©
        const buttons = document.querySelectorAll('.difficulty-btn[data-difficulty]');
        buttons.forEach(b => b.classList.remove('active'));
        
        // Activer le mode grille vierge
        isEmptyGridMode = true;
        
        // Cr√©er une grille vide
        const emptyGrid = Array(9).fill().map(() => Array(9).fill(0));
        currentPuzzle = emptyGrid;
        solution = null; // Pas de solution pr√©d√©finie
        
        // Afficher la grille vide (toutes les cases sont √©ditables)
        const cells = document.querySelectorAll('.cell');
        givenCells = [];
        
        cells.forEach((cell, index) => {
            const input = cell.querySelector('input');
            
            cell.classList.remove('given', 'solved', 'error');
            input.disabled = false;
            input.value = '';
        });
        
        checkGridCompletion();
        updateAllHints();
    }

    function updateDifficultyInfo() {
        // Fonction d√©sactiv√©e - la bande d'information a √©t√© supprim√©e
    }

    function generateCompleteSudoku() {
        const grid = Array(9).fill().map(() => Array(9).fill(0));
        
        function isValid(grid, row, col, num) {
            // V√©rifier la ligne
            for (let x = 0; x < 9; x++) {
                if (grid[row][x] === num) return false;
            }
            
            // V√©rifier la colonne
            for (let x = 0; x < 9; x++) {
                if (grid[x][col] === num) return false;
            }
            
            // V√©rifier le carr√© 3x3
            const startRow = row - row % 3;
            const startCol = col - col % 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (grid[i + startRow][j + startCol] === num) return false;
                }
            }
            
            return true;
        }
        
        function fillGrid(grid) {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (grid[row][col] === 0) {
                        const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                        shuffleArray(numbers);
                        
                        for (let num of numbers) {
                            if (isValid(grid, row, col, num)) {
                                grid[row][col] = num;
                                
                                if (fillGrid(grid)) {
                                    return true;
                                }
                                
                                grid[row][col] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        }
        
        fillGrid(grid);
        return grid;
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function generateNewSudoku() {
        // D√©sactiver le mode grille vierge
        isEmptyGridMode = false;
        
        const maxAttempts = 100;
        let attempts = 0;
        let puzzle, completeGrid, difficulty;
        
        // Essayer de g√©n√©rer une grille avec la bonne difficult√©
        do {
            completeGrid = generateCompleteSudoku();
            solution = completeGrid.map(row => [...row]);
            
            puzzle = completeGrid.map(row => [...row]);
            
            // Retirer des cases une par une en v√©rifiant que la grille reste unique
            const targetClues = difficultyLevels[currentDifficulty].clues;
            const positions = [];
            for (let i = 0; i < 81; i++) positions.push(i);
            shuffleArray(positions);
            
            let cluesCount = 81;
            for (let pos of positions) {
                if (cluesCount <= targetClues) break;
                
                const row = Math.floor(pos / 9);
                const col = pos % 9;
                const backup = puzzle[row][col];
                puzzle[row][col] = 0;
                
                // V√©rifier que la solution reste unique
                if (hasUniqueSolution(puzzle)) {
                    cluesCount--;
                } else {
                    puzzle[row][col] = backup;
                }
            }
            
            // √âvaluer la difficult√© r√©elle
            difficulty = evaluateDifficulty(puzzle);
            attempts++;
            
        } while (!isDifficultyMatch(difficulty, currentDifficulty) && attempts < maxAttempts);
        
        currentPuzzle = puzzle;
        displayPuzzle(puzzle);
    }

    function evaluateDifficulty(puzzle) {
        const grid = puzzle.map(row => [...row]);
        let simples = 0;
        let hiddenSingles = 0;
        let pairs = 0;
        let triples = 0;
        let needsGuessing = false;
        
        // Simuler la r√©solution en comptant les techniques n√©cessaires
        while (!isGridComplete(grid)) {
            let progress = false;
            
            // V√©rifier les simples (naked singles)
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (grid[row][col] === 0) {
                        const candidates = getCandidatesForCell(grid, row, col);
                        if (candidates.length === 1) {
                            grid[row][col] = candidates[0];
                            simples++;
                            progress = true;
                        }
                    }
                }
            }
            
            if (progress) continue;
            
            // V√©rifier les hidden singles
            const hidden = findHiddenSingles(grid);
            if (hidden) {
                hiddenSingles++;
                progress = true;
                continue;
            }
            
            // Si aucune technique simple ne fonctionne, la grille n√©cessite des techniques avanc√©es
            if (!progress) {
                needsGuessing = true;
                break;
            }
        }
        
        return { simples, hiddenSingles, pairs, triples, needsGuessing };
    }

    function isDifficultyMatch(evaluated, targetDifficulty) {
        switch(targetDifficulty) {
            case 'facile':
                // Facile : uniquement des simples, au moins 15 simples
                return evaluated.simples >= 15 && !evaluated.needsGuessing;
            case 'moyen':
                // Moyen : simples + hidden singles, pas de techniques avanc√©es
                return evaluated.simples >= 5 && evaluated.hiddenSingles >= 3 && !evaluated.needsGuessing;
            case 'difficile':
                // Difficile : n√©cessite des techniques avanc√©es mais r√©solvable logiquement
                return (evaluated.hiddenSingles >= 5 || evaluated.needsGuessing);
            case 'expert':
                // Expert : n√©cessite backtracking ou techniques tr√®s avanc√©es
                return evaluated.needsGuessing;
            default:
                return true;
        }
    }

    function getCandidatesForCell(grid, row, col) {
        const candidates = [];
        for (let num = 1; num <= 9; num++) {
            if (isValidPlacement(grid, row, col, num)) {
                candidates.push(num);
            }
        }
        return candidates;
    }

    function findHiddenSingles(grid) {
        // V√©rifier les lignes
        for (let row = 0; row < 9; row++) {
            for (let num = 1; num <= 9; num++) {
                let positions = [];
                for (let col = 0; col < 9; col++) {
                    if (grid[row][col] === 0 && isValidPlacement(grid, row, col, num)) {
                        positions.push(col);
                    }
                }
                if (positions.length === 1) {
                    grid[row][positions[0]] = num;
                    return true;
                }
            }
        }
        
        // V√©rifier les colonnes
        for (let col = 0; col < 9; col++) {
            for (let num = 1; num <= 9; num++) {
                let positions = [];
                for (let row = 0; row < 9; row++) {
                    if (grid[row][col] === 0 && isValidPlacement(grid, row, col, num)) {
                        positions.push(row);
                    }
                }
                if (positions.length === 1) {
                    grid[positions[0]][col] = num;
                    return true;
                }
            }
        }
        
        // V√©rifier les blocs 3x3
        for (let boxRow = 0; boxRow < 3; boxRow++) {
            for (let boxCol = 0; boxCol < 3; boxCol++) {
                for (let num = 1; num <= 9; num++) {
                    let positions = [];
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            const row = boxRow * 3 + i;
                            const col = boxCol * 3 + j;
                            if (grid[row][col] === 0 && isValidPlacement(grid, row, col, num)) {
                                positions.push([row, col]);
                            }
                        }
                    }
                    if (positions.length === 1) {
                        grid[positions[0][0]][positions[0][1]] = num;
                        return true;
                    }
                }
            }
        }
        
        return false;
    }

    function isGridComplete(grid) {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (grid[row][col] === 0) return false;
            }
        }
        return true;
    }

    function hasUniqueSolution(puzzle) {
        const grid = puzzle.map(row => [...row]);
        let solutionCount = 0;
        
        function countSolutions(g) {
            if (solutionCount > 1) return; // Arr√™ter si plus d'une solution
            
            // Trouver une case vide
            let row = -1, col = -1;
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (g[r][c] === 0) {
                        row = r;
                        col = c;
                        break;
                    }
                }
                if (row !== -1) break;
            }
            
            if (row === -1) {
                solutionCount++;
                return;
            }
            
            for (let num = 1; num <= 9; num++) {
                if (isValidPlacement(g, row, col, num)) {
                    g[row][col] = num;
                    countSolutions(g);
                    g[row][col] = 0;
                    
                    if (solutionCount > 1) return;
                }
            }
        }
        
        countSolutions(grid);
        return solutionCount === 1;
    }

    function displayPuzzle(puzzle) {
        const cells = document.querySelectorAll('.cell');
        givenCells = [];
        
        cells.forEach((cell, index) => {
            const row = Math.floor(index / 9);
            const col = index % 9;
            const input = cell.querySelector('input');
            const value = puzzle[row][col];
            
            cell.classList.remove('given', 'solved', 'error');
            input.disabled = false;
            
            if (value !== 0) {
                input.value = value;
                cell.classList.add('given');
                input.disabled = true;
                givenCells.push(index);
            } else {
                input.value = '';
            }
        });
        
        checkGridCompletion();
        updateAllHints();
    }

    function solveSudoku() {
        // Si pas de solution pr√©d√©finie (grille vierge), r√©soudre la grille actuelle
        if (!solution) {
            const cells = document.querySelectorAll('.cell input');
            const currentGrid = Array(9).fill().map(() => Array(9).fill(0));
            
            // R√©cup√©rer la grille actuelle
            cells.forEach((input, index) => {
                const row = Math.floor(index / 9);
                const col = index % 9;
                const value = parseInt(input.value);
                if (value) {
                    currentGrid[row][col] = value;
                }
            });
            
            // Essayer de r√©soudre
            if (solveSudokuGrid(currentGrid)) {
                solution = currentGrid;
                
                // Afficher la solution
                cells.forEach((input, index) => {
                    const row = Math.floor(index / 9);
                    const col = index % 9;
                    const cell = input.parentElement;
                    
                    if (!givenCells.includes(index)) {
                        input.value = solution[row][col];
                        cell.classList.add('solved');
                    }
                });
            } else {
                alert('‚ö†Ô∏è Cette grille n\'a pas de solution valide ou contient des erreurs.');
            }
        } else {
            // Solution pr√©d√©finie disponible
            const cells = document.querySelectorAll('.cell');
            
            cells.forEach((cell, index) => {
                const row = Math.floor(index / 9);
                const col = index % 9;
                const input = cell.querySelector('input');
                
                if (!givenCells.includes(index)) {
                    input.value = solution[row][col];
                    cell.classList.add('solved');
                }
            });
        }
    }

    function solveSudokuGrid(grid) {
        // Trouver une case vide
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (grid[row][col] === 0) {
                    // Essayer les chiffres de 1 √† 9
                    for (let num = 1; num <= 9; num++) {
                        if (isValidPlacement(grid, row, col, num)) {
                            grid[row][col] = num;
                            
                            if (solveSudokuGrid(grid)) {
                                return true;
                            }
                            
                            grid[row][col] = 0;
                        }
                    }
                    return false;
                }
            }
        }
        return true; // Grille compl√®te
    }

    function isValidPlacement(grid, row, col, num) {
        // V√©rifier la ligne
        for (let x = 0; x < 9; x++) {
            if (grid[row][x] === num) return false;
        }
        
        // V√©rifier la colonne
        for (let x = 0; x < 9; x++) {
            if (grid[x][col] === num) return false;
        }
        
        // V√©rifier le carr√© 3x3
        const startRow = row - row % 3;
        const startCol = col - col % 3;
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (grid[i + startRow][j + startCol] === num) return false;
            }
        }
        
        return true;
    }

    function resetGrid() {
        // Si on √©tait en mode grille vierge, rester en mode grille vierge
        if (isEmptyGridMode) {
            generateEmptyGrid();
        } else {
            displayPuzzle(currentPuzzle);
        }
    }

    function checkGridCompletion() {
        const cells = document.querySelectorAll('.cell input');
        let allFilled = true;
        
        for (let cell of cells) {
            if (!cell.value) {
                allFilled = false;
                break;
            }
        }
        
        const verifyBtn = document.getElementById('verifyBtn');
        const solveBtn = document.getElementById('solveBtn');
        
        // En mode grille vierge, les boutons sont toujours actifs
        if (isEmptyGridMode) {
            verifyBtn.disabled = false;
            solveBtn.disabled = false;
        } else {
            // En mode normal, activer uniquement si toutes les cases sont remplies
            verifyBtn.disabled = !allFilled;
            solveBtn.disabled = !allFilled;
        }
    }

    function verifySudoku() {
        const cells = document.querySelectorAll('.cell');
        
        // Si pas de solution pr√©d√©finie, essayer de r√©soudre pour v√©rifier
        if (!solution) {
            const currentGrid = Array(9).fill().map(() => Array(9).fill(0));
            
            // R√©cup√©rer la grille actuelle
            cells.forEach((cell, index) => {
                const row = Math.floor(index / 9);
                const col = index % 9;
                const input = cell.querySelector('input');
                const value = parseInt(input.value);
                if (value) {
                    currentGrid[row][col] = value;
                }
            });
            
            // R√©soudre une copie de la grille
            const gridCopy = currentGrid.map(row => [...row]);
            if (solveSudokuGrid(gridCopy)) {
                solution = gridCopy;
            } else {
                alert('‚ö†Ô∏è Cette grille n\'a pas de solution valide ou contient des erreurs.');
                return;
            }
        }
        
        let hasErrors = false;
        
        cells.forEach((cell, index) => {
            const row = Math.floor(index / 9);
            const col = index % 9;
            const input = cell.querySelector('input');
            const userValue = parseInt(input.value);
            const correctValue = solution[row][col];
            
            cell.classList.remove('error');
            
            if (!givenCells.includes(index) && userValue && userValue !== correctValue) {
                cell.classList.add('error');
                hasErrors = true;
            }
        });
        
        if (!hasErrors) {
            alert('üéâ F√©licitations ! Tous les chiffres sont corrects !');
        } else {
            alert('‚ùå Il y a des erreurs. Les cases incorrectes sont en rouge.');
        }
    }

    function toggleCandidates() {
        updateAllHints();
    }

    function toggleSimples() {
        updateAllHints();
    }

    function togglePointingPairs() {
        updateAllHints();
    }

    function toggleTriples() {
        updateAllHints();
    }

    function toggleRows() {
        updateAllHints();
    }

    function toggleColumns() {
        updateAllHints();
    }

    function toggleAriane() {
        updateAllHints();
    }

    function toggleXWing() {
        updateAllHints();
    }

    function updateAllHints() {
        const showPairs = document.getElementById('showCandidates').checked;
        const showSimples = document.getElementById('showSimples').checked;
        const showTriples = document.getElementById('showTriples').checked;
        const showRows = document.getElementById('showRows').checked;
        const showColumns = document.getElementById('showColumns').checked;
        
        if (showPairs) {
            updatePairHints();
        } else {
            document.querySelectorAll('.pair-hint-right, .pair-hint-bottom').forEach(hint => {
                hint.classList.remove('show');
                hint.textContent = '';
            });
        }
        
        if (showSimples) {
            updateSimpleHints();
        } else {
            document.querySelectorAll('.simple-hint').forEach(hint => {
                hint.classList.remove('show');
                hint.textContent = '';
            });
        }
        
        if (showTriples) {
            updateTripleHints();
        } else {
            document.querySelectorAll('.triple-hint-left, .triple-hint-top').forEach(hint => {
                hint.classList.remove('show');
                hint.textContent = '';
            });
        }
        
        if (showRows) {
            updateRowHints();
        } else {
            document.querySelectorAll('.row-hint').forEach(hint => {
                hint.classList.remove('show');
                hint.innerHTML = '';
            });
        }
        
        if (showColumns) {
            updateColumnHints();
        } else {
            document.querySelectorAll('.column-hint').forEach(hint => {
                hint.classList.remove('show');
                hint.innerHTML = '';
            });
        }
    }

    function updateRowHints() {
        const cells = document.querySelectorAll('.cell input');
        
        for (let row = 0; row < 9; row++) {
            const missing = [];
            const present = new Set();
            
            // Trouver les chiffres pr√©sents dans la ligne
            for (let col = 0; col < 9; col++) {
                const index = row * 9 + col;
                const value = parseInt(cells[index].value);
                if (value) {
                    present.add(value);
                }
            }
            
            // Trouver les chiffres manquants
            for (let num = 1; num <= 9; num++) {
                if (!present.has(num)) {
                    missing.push(num);
                }
            }
            
            // Afficher les chiffres manquants sur 3 lignes (max 3 chiffres par ligne)
            const rowHint = document.getElementById(`row-hint-${row}`);
            if (missing.length > 0) {
                const lines = [];
                for (let i = 0; i < missing.length; i += 3) {
                    const group = missing.slice(i, i + 3).join(' ');
                    lines.push(`<div class="row-hint-line">${group}</div>`);
                }
                rowHint.innerHTML = lines.join('');
                rowHint.classList.add('show');
            } else {
                rowHint.classList.remove('show');
                rowHint.innerHTML = '';
            }
        }
    }

    function updateColumnHints() {
        const cells = document.querySelectorAll('.cell input');
        
        for (let col = 0; col < 9; col++) {
            const missing = [];
            const present = new Set();
            
            // Trouver les chiffres pr√©sents dans la colonne
            for (let row = 0; row < 9; row++) {
                const index = row * 9 + col;
                const value = parseInt(cells[index].value);
                if (value) {
                    present.add(value);
                }
            }
            
            // Trouver les chiffres manquants
            for (let num = 1; num <= 9; num++) {
                if (!present.has(num)) {
                    missing.push(num);
                }
            }
            
            // Afficher les chiffres manquants sur 3 lignes (max 3 chiffres par ligne)
            const columnHint = document.getElementById(`column-hint-${col}`);
            if (missing.length > 0) {
                const lines = [];
                for (let i = 0; i < missing.length; i += 3) {
                    const group = missing.slice(i, i + 3).join(' ');
                    lines.push(`<div class="column-hint-line">${group}</div>`);
                }
                columnHint.innerHTML = lines.join('');
                columnHint.classList.add('show');
            } else {
                columnHint.classList.remove('show');
                columnHint.innerHTML = '';
            }
        }
    }

    function updateAllHints() {
        const showPairs = document.getElementById('showCandidates').checked;
        const showSimples = document.getElementById('showSimples').checked;
        const showPointingPairs = document.getElementById('showPointingPairs').checked;
        const showTriples = document.getElementById('showTriples').checked;
        const showRows = document.getElementById('showRows').checked;
        const showColumns = document.getElementById('showColumns').checked;
        const showAriane = document.getElementById('showAriane').checked;
        const showXWing = document.getElementById('showXWing').checked;
        
        if (showPairs) {
            updatePairHints();
        } else {
            document.querySelectorAll('.pair-hint-right, .pair-hint-bottom').forEach(hint => {
                hint.classList.remove('show');
                hint.textContent = '';
            });
        }
        
        if (showSimples) {
            updateSimpleHints();
        } else {
            document.querySelectorAll('.simple-hint').forEach(hint => {
                hint.classList.remove('show');
                hint.textContent = '';
            });
        }
        
        if (showPointingPairs) {
            updatePointingPairsHints();
        } else {
            document.querySelectorAll('.pointing-pair-right, .pointing-pair-bottom').forEach(hint => {
                hint.classList.remove('show');
                hint.textContent = '';
            });
        }
        
        if (showTriples) {
            updateTripleHints();
        } else {
            document.querySelectorAll('.triple-hint-left, .triple-hint-top').forEach(hint => {
                hint.classList.remove('show');
                hint.textContent = '';
            });
        }
        
        if (showRows) {
            updateRowHints();
        } else {
            document.querySelectorAll('.row-hint').forEach(hint => {
                hint.classList.remove('show');
                hint.innerHTML = '';
            });
        }
        
        if (showColumns) {
            updateColumnHints();
        } else {
            document.querySelectorAll('.column-hint').forEach(hint => {
                hint.classList.remove('show');
                hint.innerHTML = '';
            });
        }
        
        if (showAriane) {
            updateArianeHint();
        } else {
            document.querySelectorAll('.ariane-hint').forEach(hint => {
                hint.classList.remove('show');
                hint.innerHTML = '';
            });
        }
        
        if (showXWing) {
            updateXWingHint();
        } else {
            const overlay = document.getElementById('xwingOverlay');
            if (overlay) {
                overlay.classList.remove('show');
                overlay.innerHTML = '';
            }
        }
    }

    function updateSimpleHints() {
        const cells = document.querySelectorAll('.cell');
        
        // R√©initialiser tous les indices simples
        document.querySelectorAll('.simple-hint').forEach(hint => {
            hint.classList.remove('show');
            hint.textContent = '';
        });
        
        // 1. Trouver les Naked Singles (une seule possibilit√© dans la case)
        cells.forEach((cell, index) => {
            const row = Math.floor(index / 9);
            const col = index % 9;
            const input = cell.querySelector('input');
            
            // Ignorer les cases pr√©-remplies ou d√©j√† remplies
            if (givenCells.includes(index) || input.value) return;
            
            const candidates = getCandidates(row, col);
            
            // Debug am√©lior√© pour B9 (row=8, col=1, index=73)
            if (index === 73) {
                const allCells = document.querySelectorAll('.cell input');
                
                // Ligne 8
                const rowValues = [];
                for (let c = 0; c < 9; c++) {
                    const v = allCells[8 * 9 + c].value.trim();
                    if (v) rowValues.push(v);
                }
                
                // Colonne 1
                const colValues = [];
                for (let r = 0; r < 9; r++) {
                    const v = allCells[r * 9 + 1].value.trim();
                    if (v) colValues.push(v);
                }
                
                // Bloc 3x3
                const boxValues = [];
                for (let r = 6; r < 9; r++) {
                    for (let c = 0; c < 3; c++) {
                        const v = allCells[r * 9 + c].value.trim();
                        if (v) boxValues.push(v);
                    }
                }
                
                console.log(`B9 (index ${index}, row ${row}, col ${col}):`);
                console.log(`  Row 8 values: [${rowValues.join(', ')}]`);
                console.log(`  Col 1 values: [${colValues.join(', ')}]`);
                console.log(`  Box values: [${boxValues.join(', ')}]`);
                console.log(`  Candidates: [${candidates.join(', ')}]`);
                console.log(`  Input value: "${input.value}" (empty: ${!input.value})`);
                console.log(`  Is given: ${givenCells.includes(index)}`);
            }
            
            // Si une seule possibilit√© existe
            if (candidates.length === 1) {
                const simpleHint = cell.querySelector('.simple-hint');
                simpleHint.textContent = candidates[0];
                simpleHint.classList.add('show');
            }
        });
        
        // 2. Trouver les Hidden Singles (seul endroit dans ligne/colonne/zone pour un chiffre)
        
        // Hidden Singles dans les lignes
        for (let row = 0; row < 9; row++) {
            for (let num = 1; num <= 9; num++) {
                const possibleCols = [];
                for (let col = 0; col < 9; col++) {
                    const index = row * 9 + col;
                    const input = cells[index].querySelector('input');
                    if (!givenCells.includes(index) && !input.value) {
                        const candidates = getCandidates(row, col);
                        if (candidates.includes(num)) {
                            possibleCols.push(col);
                        }
                    }
                }
                if (possibleCols.length === 1) {
                    const col = possibleCols[0];
                    const index = row * 9 + col;
                    const cell = cells[index];
                    const simpleHint = cell.querySelector('.simple-hint');
                    if (!simpleHint.textContent) { // Ne pas √©craser un Naked Single
                        simpleHint.textContent = num;
                        simpleHint.classList.add('show');
                    }
                }
            }
        }
        
        // Hidden Singles dans les colonnes
        for (let col = 0; col < 9; col++) {
            for (let num = 1; num <= 9; num++) {
                const possibleRows = [];
                for (let row = 0; row < 9; row++) {
                    const index = row * 9 + col;
                    const input = cells[index].querySelector('input');
                    if (!givenCells.includes(index) && !input.value) {
                        const candidates = getCandidates(row, col);
                        if (candidates.includes(num)) {
                            possibleRows.push(row);
                        }
                    }
                }
                if (possibleRows.length === 1) {
                    const row = possibleRows[0];
                    const index = row * 9 + col;
                    const cell = cells[index];
                    const simpleHint = cell.querySelector('.simple-hint');
                    if (!simpleHint.textContent) { // Ne pas √©craser un Naked Single
                        simpleHint.textContent = num;
                        simpleHint.classList.add('show');
                    }
                }
            }
        }
        
        // Hidden Singles dans les zones 3√ó3
        for (let boxRow = 0; boxRow < 3; boxRow++) {
            for (let boxCol = 0; boxCol < 3; boxCol++) {
                for (let num = 1; num <= 9; num++) {
                    const possiblePositions = [];
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            const row = boxRow * 3 + i;
                            const col = boxCol * 3 + j;
                            const index = row * 9 + col;
                            const input = cells[index].querySelector('input');
                            if (!givenCells.includes(index) && !input.value) {
                                const candidates = getCandidates(row, col);
                                if (candidates.includes(num)) {
                                    possiblePositions.push({ row, col, index });
                                }
                            }
                        }
                    }
                    if (possiblePositions.length === 1) {
                        const pos = possiblePositions[0];
                        const cell = cells[pos.index];
                        const simpleHint = cell.querySelector('.simple-hint');
                        if (!simpleHint.textContent) { // Ne pas √©craser un Naked ou Hidden Single d√©j√† trouv√©
                            simpleHint.textContent = num;
                            simpleHint.classList.add('show');
                        }
                    }
                }
            }
        }
    }

    function updatePointingPairsHints() {
        const cells = document.querySelectorAll('.cell');
        
        // R√©initialiser tous les pointing pairs
        document.querySelectorAll('.pointing-pair-right, .pointing-pair-bottom').forEach(hint => {
            hint.classList.remove('show');
            hint.textContent = '';
        });
        
        // Trouver les pointing pairs dans chaque zone 3x3
        for (let boxRow = 0; boxRow < 3; boxRow++) {
            for (let boxCol = 0; boxCol < 3; boxCol++) {
                // Pour chaque chiffre de 1 √† 9
                for (let num = 1; num <= 9; num++) {
                    const positions = [];
                    
                    // Trouver toutes les positions possibles pour ce chiffre dans cette zone
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            const row = boxRow * 3 + i;
                            const col = boxCol * 3 + j;
                            const index = row * 9 + col;
                            const input = cells[index].querySelector('input');
                            
                            if (!givenCells.includes(index) && !input.value) {
                                const candidates = getCandidates(row, col);
                                if (candidates.includes(num)) {
                                    positions.push({ row, col, index });
                                }
                            }
                        }
                    }
                    
                    // Si exactement 2 positions et elles sont contigu√´s
                    if (positions.length === 2) {
                        const pos1 = positions[0];
                        const pos2 = positions[1];
                        
                        // V√©rifier si contigu√´s horizontalement
                        if (pos1.row === pos2.row && Math.abs(pos1.col - pos2.col) === 1) {
                            const leftIndex = pos1.col < pos2.col ? pos1.index : pos2.index;
                            const leftCell = cells[leftIndex];
                            const pointingHint = leftCell.querySelector('.pointing-pair-right');
                            pointingHint.textContent = num;
                            pointingHint.classList.add('show');
                        }
                        
                        // V√©rifier si contigu√´s verticalement
                        if (pos1.col === pos2.col && Math.abs(pos1.row - pos2.row) === 1) {
                            const topIndex = pos1.row < pos2.row ? pos1.index : pos2.index;
                            const topCell = cells[topIndex];
                            const pointingHint = topCell.querySelector('.pointing-pair-bottom');
                            pointingHint.textContent = num;
                            pointingHint.classList.add('show');
                        }
                    }
                }
            }
        }
    }

    function updateTripleHints() {
        const cells = document.querySelectorAll('.cell');
        
        // R√©initialiser tous les indices triples
        document.querySelectorAll('.triple-hint-left, .triple-hint-top').forEach(hint => {
            hint.classList.remove('show');
            hint.textContent = '';
        });
        
        // V√©rifier les triples horizontaux (par ligne)
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col <= 6; col++) {
                const indices = [row * 9 + col, row * 9 + col + 1, row * 9 + col + 2];
                
                // V√©rifier que les 3 cases sont dans la m√™me zone 3x3
                const box1 = Math.floor(row / 3) * 3 + Math.floor(col / 3);
                const box2 = Math.floor(row / 3) * 3 + Math.floor((col + 1) / 3);
                const box3 = Math.floor(row / 3) * 3 + Math.floor((col + 2) / 3);
                
                if (box1 !== box2 || box2 !== box3) continue;
                
                const cellsGroup = indices.map(i => cells[i]);
                const inputs = cellsGroup.map(c => c.querySelector('input'));
                
                // V√©rifier que les 3 cases sont vides et non pr√©-remplies
                if (indices.every((idx, i) => !givenCells.includes(idx) && !inputs[i].value)) {
                    const candidateSets = indices.map(i => {
                        const r = Math.floor(i / 9);
                        const c = i % 9;
                        return getCandidates(r, c);
                    });
                    
                    // Union de tous les candidats des 3 cases
                    const unionCandidates = [...new Set(candidateSets.flat())];
                    
                    // V√©rifier si exactement 3 chiffres couvrent toutes les possibilit√©s
                    if (unionCandidates.length === 3) {
                        // V√©rifier que chaque case a au moins 2 candidats parmi ces 3
                        const allValid = candidateSets.every(set => 
                            set.length >= 2 && set.every(c => unionCandidates.includes(c))
                        );
                        
                        if (allValid) {
                            const tripleHint = cellsGroup[0].querySelector('.triple-hint-left');
                            tripleHint.textContent = unionCandidates.sort().join('');
                            tripleHint.classList.add('show');
                        }
                    }
                }
            }
        }
        
        // V√©rifier les triples verticaux (par colonne)
        for (let col = 0; col < 9; col++) {
            for (let row = 0; row <= 6; row++) {
                const indices = [row * 9 + col, (row + 1) * 9 + col, (row + 2) * 9 + col];
                
                // V√©rifier que les 3 cases sont dans la m√™me zone 3x3
                const box1 = Math.floor(row / 3) * 3 + Math.floor(col / 3);
                const box2 = Math.floor((row + 1) / 3) * 3 + Math.floor(col / 3);
                const box3 = Math.floor((row + 2) / 3) * 3 + Math.floor(col / 3);
                
                if (box1 !== box2 || box2 !== box3) continue;
                
                const cellsGroup = indices.map(i => cells[i]);
                const inputs = cellsGroup.map(c => c.querySelector('input'));
                
                // V√©rifier que les 3 cases sont vides et non pr√©-remplies
                if (indices.every((idx, i) => !givenCells.includes(idx) && !inputs[i].value)) {
                    const candidateSets = indices.map(i => {
                        const r = Math.floor(i / 9);
                        const c = i % 9;
                        return getCandidates(r, c);
                    });
                    
                    // Union de tous les candidats des 3 cases
                    const unionCandidates = [...new Set(candidateSets.flat())];
                    
                    // V√©rifier si exactement 3 chiffres couvrent toutes les possibilit√©s
                    if (unionCandidates.length === 3) {
                        // V√©rifier que chaque case a au moins 2 candidats parmi ces 3
                        const allValid = candidateSets.every(set => 
                            set.length >= 2 && set.every(c => unionCandidates.includes(c))
                        );
                        
                        if (allValid) {
                            const tripleHint = cellsGroup[0].querySelector('.triple-hint-top');
                            tripleHint.textContent = unionCandidates.sort().join('');
                            tripleHint.classList.add('show');
                        }
                    }
                }
            }
        }
    }

    function updatePairHints() {
        const cells = document.querySelectorAll('.cell');
        
        // R√©initialiser tous les indices
        document.querySelectorAll('.pair-hint-right, .pair-hint-bottom').forEach(hint => {
            hint.classList.remove('show');
            hint.textContent = '';
        });
        
        // Parcourir chaque case
        cells.forEach((cell, index) => {
            const row = Math.floor(index / 9);
            const col = index % 9;
            const input = cell.querySelector('input');
            
            // Ignorer les cases pr√©-remplies ou d√©j√† remplies
            if (givenCells.includes(index) || input.value) return;
            
            const candidates = getCandidates(row, col);
            
            // V√©rifier uniquement si cette case a exactement 2 candidats
            if (candidates.length === 2) {
                const box1 = Math.floor(row / 3) * 3 + Math.floor(col / 3);
                
                // V√©rifier la case √† droite (m√™me ligne)
                if (col < 8) {
                    const rightIndex = index + 1;
                    const rightInput = cells[rightIndex].querySelector('input');
                    const box2 = Math.floor(row / 3) * 3 + Math.floor((col + 1) / 3);
                    
                    // V√©rifier qu'elles sont dans la m√™me zone 3x3
                    if (box1 === box2 && !givenCells.includes(rightIndex) && !rightInput.value) {
                        const rightCandidates = getCandidates(row, col + 1);
                        
                        // Si les deux cases ont exactement les m√™mes 2 candidats
                        if (rightCandidates.length === 2 && 
                            candidates[0] === rightCandidates[0] && 
                            candidates[1] === rightCandidates[1]) {
                            const pairHint = cell.querySelector('.pair-hint-right');
                            pairHint.textContent = candidates.join('');
                            pairHint.classList.add('show');
                        }
                    }
                }
                
                // V√©rifier la case en bas (m√™me colonne)
                if (row < 8) {
                    const bottomIndex = index + 9;
                    const bottomInput = cells[bottomIndex].querySelector('input');
                    const box2 = Math.floor((row + 1) / 3) * 3 + Math.floor(col / 3);
                    
                    // V√©rifier qu'elles sont dans la m√™me zone 3x3
                    if (box1 === box2 && !givenCells.includes(bottomIndex) && !bottomInput.value) {
                        const bottomCandidates = getCandidates(row + 1, col);
                        
                        // Si les deux cases ont exactement les m√™mes 2 candidats
                        if (bottomCandidates.length === 2 && 
                            candidates[0] === bottomCandidates[0] && 
                            candidates[1] === bottomCandidates[1]) {
                            const pairHint = cell.querySelector('.pair-hint-bottom');
                            pairHint.textContent = candidates.join('');
                            pairHint.classList.add('show');
                        }
                    }
                }
            }
        });
    }

    function getCandidates(row, col) {
        const candidates = [];
        const cells = document.querySelectorAll('.cell input');
        
        for (let num = 1; num <= 9; num++) {
            let isValid = true;
            
            // V√©rifier la ligne
            for (let c = 0; c < 9; c++) {
                const cellIndex = row * 9 + c;
                const value = cells[cellIndex].value.trim();
                if (value !== '' && parseInt(value) === num) {
                    isValid = false;
                    break;
                }
            }
            
            // V√©rifier la colonne
            if (isValid) {
                for (let r = 0; r < 9; r++) {
                    const cellIndex = r * 9 + col;
                    const value = cells[cellIndex].value.trim();
                    if (value !== '' && parseInt(value) === num) {
                        isValid = false;
                        break;
                    }
                }
            }
            
            // V√©rifier le carr√© 3x3
            if (isValid) {
                const startRow = Math.floor(row / 3) * 3;
                const startCol = Math.floor(col / 3) * 3;
                for (let r = startRow; r < startRow + 3; r++) {
                    for (let c = startCol; c < startCol + 3; c++) {
                        const cellIndex = r * 9 + c;
                        const value = cells[cellIndex].value.trim();
                        if (value !== '' && parseInt(value) === num) {
                            isValid = false;
                            break;
                        }
                    }
                    if (!isValid) break;
                }
            }
            
            if (isValid) {
                candidates.push(num);
            }
        }
        
        return candidates;
    }

    function updateArianeHint() {
        const cells = document.querySelectorAll('.cell');
        
        // R√©initialiser tous les indices Ariane
        document.querySelectorAll('.ariane-hint').forEach(hint => {
            hint.classList.remove('show');
            hint.innerHTML = '';
        });
        
        // V√©rifier s'il existe des techniques logiques disponibles
        if (hasLogicalTechniquesAvailable()) {
            // Il reste des techniques logiques, ne pas afficher Ariane
            return;
        }
        
        // Plus de techniques logiques disponibles : chercher la meilleure case pour le fil d'Ariane
        // Crit√®re : case vide avec le moins de candidats (mais au moins 2)
        let bestCell = null;
        let minCandidates = 10;
        
        cells.forEach((cell, index) => {
            const row = Math.floor(index / 9);
            const col = index % 9;
            const input = cell.querySelector('input');
            
            if (!givenCells.includes(index) && !input.value) {
                const candidates = getCandidates(row, col);
                
                // On cherche une case avec 2-4 candidats (id√©al pour fil d'Ariane)
                if (candidates.length >= 2 && candidates.length < minCandidates) {
                    minCandidates = candidates.length;
                    bestCell = { index, row, col, candidates };
                }
            }
        });
        
        // Afficher l'indice Ariane sur la meilleure case
        if (bestCell) {
            const cell = cells[bestCell.index];
            const arianeHint = cell.querySelector('.ariane-hint');
            
            // Cr√©er l'affichage des candidats avec le premier en gras
            const candidatesHtml = bestCell.candidates.map((num, idx) => {
                if (idx === 0) {
                    return `<span class="ariane-best">${num}</span>`;
                }
                return `<span>${num}</span>`;
            }).join(' ');
            
            arianeHint.innerHTML = `<div class="ariane-candidates">${candidatesHtml}</div>`;
            arianeHint.classList.add('show');
        }
    }

    function hasLogicalTechniquesAvailable() {
        const cells = document.querySelectorAll('.cell');
        
        // 1. V√©rifier s'il existe des Naked Singles (simples)
        for (let i = 0; i < cells.length; i++) {
            const row = Math.floor(i / 9);
            const col = i % 9;
            const input = cells[i].querySelector('input');
            
            if (!givenCells.includes(i) && !input.value) {
                const candidates = getCandidates(row, col);
                if (candidates.length === 1) {
                    return true; // Il existe un simple
                }
            }
        }
        
        // 2. V√©rifier s'il existe des Hidden Singles (lignes)
        for (let row = 0; row < 9; row++) {
            for (let num = 1; num <= 9; num++) {
                const possibleCols = [];
                for (let col = 0; col < 9; col++) {
                    const index = row * 9 + col;
                    const input = cells[index].querySelector('input');
                    if (!givenCells.includes(index) && !input.value) {
                        const candidates = getCandidates(row, col);
                        if (candidates.includes(num)) {
                            possibleCols.push(col);
                        }
                    }
                }
                if (possibleCols.length === 1) {
                    return true; // Il existe un hidden single
                }
            }
        }
        
        // 3. V√©rifier s'il existe des Hidden Singles (colonnes)
        for (let col = 0; col < 9; col++) {
            for (let num = 1; num <= 9; num++) {
                const possibleRows = [];
                for (let row = 0; row < 9; row++) {
                    const index = row * 9 + col;
                    const input = cells[index].querySelector('input');
                    if (!givenCells.includes(index) && !input.value) {
                        const candidates = getCandidates(row, col);
                        if (candidates.includes(num)) {
                            possibleRows.push(row);
                        }
                    }
                }
                if (possibleRows.length === 1) {
                    return true; // Il existe un hidden single
                }
            }
        }
        
        // 4. V√©rifier s'il existe des Hidden Singles (zones 3√ó3)
        for (let boxRow = 0; boxRow < 3; boxRow++) {
            for (let boxCol = 0; boxCol < 3; boxCol++) {
                for (let num = 1; num <= 9; num++) {
                    const possiblePositions = [];
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            const row = boxRow * 3 + i;
                            const col = boxCol * 3 + j;
                            const index = row * 9 + col;
                            const input = cells[index].querySelector('input');
                            if (!givenCells.includes(index) && !input.value) {
                                const candidates = getCandidates(row, col);
                                if (candidates.includes(num)) {
                                    possiblePositions.push({ row, col });
                                }
                            }
                        }
                    }
                    if (possiblePositions.length === 1) {
                        return true; // Il existe un hidden single
                    }
                }
            }
        }
        
        // Aucun simple (naked ou hidden) disponible
        // Les doubles, paires, triples, X-Wing sont des techniques avanc√©es optionnelles
        return false;
    }

    function updateXWingHint() {
        const cells = document.querySelectorAll('.cell input');
        const overlay = document.getElementById('xwingOverlay');
        
        if (!overlay) return;
        
        overlay.innerHTML = '';
        overlay.classList.remove('show');
        
        // Chercher des X-Wings pour chaque chiffre
        for (let num = 1; num <= 9; num++) {
            // X-Wing dans les lignes
            const rowXWing = findRowXWing(cells, num);
            if (rowXWing) {
                drawXWing(overlay, rowXWing, num);
                overlay.classList.add('show');
                return; // Afficher seulement le premier X-Wing trouv√©
            }
            
            // X-Wing dans les colonnes
            const colXWing = findColXWing(cells, num);
            if (colXWing) {
                drawXWing(overlay, colXWing, num);
                overlay.classList.add('show');
                return;
            }
        }
    }

    function findRowXWing(cells, num) {
        // Pour chaque paire de lignes
        for (let row1 = 0; row1 < 8; row1++) {
            for (let row2 = row1 + 1; row2 < 9; row2++) {
                const cols1 = [];
                const cols2 = [];
                
                // Trouver les colonnes possibles dans chaque ligne
                for (let col = 0; col < 9; col++) {
                    const index1 = row1 * 9 + col;
                    const index2 = row2 * 9 + col;
                    
                    if (!givenCells.includes(index1) && !cells[index1].value) {
                        const candidates1 = getCandidates(row1, col);
                        if (candidates1.includes(num)) {
                            cols1.push(col);
                        }
                    }
                    
                    if (!givenCells.includes(index2) && !cells[index2].value) {
                        const candidates2 = getCandidates(row2, col);
                        if (candidates2.includes(num)) {
                            cols2.push(col);
                        }
                    }
                }
                
                // X-Wing trouv√© : exactement 2 colonnes identiques dans les 2 lignes
                if (cols1.length === 2 && cols2.length === 2 && 
                    cols1[0] === cols2[0] && cols1[1] === cols2[1]) {
                    return {
                        cells: [
                            { row: row1, col: cols1[0] },
                            { row: row1, col: cols1[1] },
                            { row: row2, col: cols2[0] },
                            { row: row2, col: cols2[1] }
                        ],
                        type: 'row'
                    };
                }
            }
        }
        return null;
    }

    function findColXWing(cells, num) {
        // Pour chaque paire de colonnes
        for (let col1 = 0; col1 < 8; col1++) {
            for (let col2 = col1 + 1; col2 < 9; col2++) {
                const rows1 = [];
                const rows2 = [];
                
                // Trouver les lignes possibles dans chaque colonne
                for (let row = 0; row < 9; row++) {
                    const index1 = row * 9 + col1;
                    const index2 = row * 9 + col2;
                    
                    if (!givenCells.includes(index1) && !cells[index1].value) {
                        const candidates1 = getCandidates(row, col1);
                        if (candidates1.includes(num)) {
                            rows1.push(row);
                        }
                    }
                    
                    if (!givenCells.includes(index2) && !cells[index2].value) {
                        const candidates2 = getCandidates(row, col2);
                        if (candidates2.includes(num)) {
                            rows2.push(row);
                        }
                    }
                }
                
                // X-Wing trouv√© : exactement 2 lignes identiques dans les 2 colonnes
                if (rows1.length === 2 && rows2.length === 2 && 
                    rows1[0] === rows2[0] && rows1[1] === rows2[1]) {
                    return {
                        cells: [
                            { row: rows1[0], col: col1 },
                            { row: rows1[0], col: col2 },
                            { row: rows1[1], col: col1 },
                            { row: rows1[1], col: col2 }
                        ],
                        type: 'col'
                    };
                }
            }
        }
        return null;
    }

    function drawXWing(overlay, xwing, num) {
        if (!xwing || !xwing.cells || xwing.cells.length !== 4) return;
        
        // Calculer les positions des 4 coins du rectangle
        const positions = xwing.cells.map(c => ({
            x: 50 + c.col * 65 + 32.5, // 50 = padding gauche, 32.5 = centre de la cellule
            y: 40 + c.row * 65 + 32.5  // 40 = padding haut
        }));
        
        // Trouver les coins du rectangle
        const minX = Math.min(...positions.map(p => p.x));
        const maxX = Math.max(...positions.map(p => p.x));
        const minY = Math.min(...positions.map(p => p.y));
        const maxY = Math.max(...positions.map(p => p.y));
        
        // Cr√©er le rectangle
        const rect = document.createElement('div');
        rect.className = 'xwing-rect';
        rect.style.left = minX + 'px';
        rect.style.top = minY + 'px';
        rect.style.width = (maxX - minX) + 'px';
        rect.style.height = (maxY - minY) + 'px';
        
        // Cr√©er le label
        const label = document.createElement('div');
        label.className = 'xwing-label';
        label.textContent = `X-Wing: ${num}`;
        label.style.left = minX + 'px';
        label.style.top = (minY - 20) + 'px';
        
        overlay.appendChild(rect);
        overlay.appendChild(label);
    }
</script>
```

</body>
</html>
